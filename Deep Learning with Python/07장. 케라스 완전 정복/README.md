# 1. 다양한 워크플로

- 케라스 API 설계 → 복잡성의 단계적 공개(Progressive Disclosure) 원칙
- 시작은 쉽게, 단계마다 점진적 학습으로 복잡한 경우도 처리 가능

# 2. 케라스 모델을 만드는 여러 방법

## 1. Sequential 모델

- 가장 시작하기 쉬운 API
- 하나의 파이썬 리스트 → 단순히 층 쌓기만 가능
- `Sequential` 클래스 : 모델 생성
    - `Input` 클래스 : 모델 입력 크기 미리 지정 → 가중치 바로 생성
- `add()` 메서드 : 모델 생성
- `build()` 메서드 : 가중치 생성
- `summary()` 메서드 : 모델 구조 출력

## 2. 함수형 API(Functional API)

- 그래프 같은 모델 구조 다룸
- 사용성, 유연성 사이 적절한 중간 지점 해당
- 가장 많이 사용되는 모델 구축 API
- 심볼릭 텐서(Symbolic Tensor) : 실제 데이터를 가지고 있지 않지만 사용할 때 모델이 보게 될 데이터 텐서 사양 인코딩
- `Input` 클래스 객체 정의 → 다음 층 생성 → 최종 출력
- 명시적인 그래프 데이터 구조 → 이전 그래프 노드를 새 모델의 일부로 재사용 가능
- `plot_model()` : 함수형 모델 그래프 생성
- 특성 추출(Feature Extraction) → 다른 모델에서 중간 특성 재사용 가능

## 3. Model 서브클래싱(Subclassing)

- 모든 것을 밑바닥부터 직접 생성 → 저수준 방법
- 모든 상세한 내용을 완전히 제어 가능
- `__init__()` 메서드 : 모델이 사용할 층 정의
- `call()` 메서드 : 생성된 층을 사용하여 모델의 정방향 패스 정의
- 서브클래스 객체 생성 → 데이터와 함께 호출하여 가중치 생성
- 층 → 모델을 만드는 데 사용하는 구성 요소
- 모델 → 실제로 훈련하고 추론에 사용하는 최상위 객체
- 층의 유향 비순환 그래프로 표현할 수 없는 모델 생성 가능
- 모델 로직 책임지기, 더 많은 디버깅 작업 필요

## 4. 여러 방식을 혼합하여 사용

- 케라스 API → 여러 방식 서로 상호 운영 가능

## 5. 작업에 적합한 도구 사용하기

- 함수형 API → 쉬운 사용성, 유연성 사이 적절한 절충점
- 층 연결 구조 → 모델 출력, 특성 추출 가능
- 층의 유향 비순환 그래프 → 함수형 API

# 3. 내장된 훈련 루프와 평가 루프 사용

- `compile()` , `fit()` , `evaluate()` , `predict()`

## 1. 사용자 정의 지표

- 훈련 데이터 성능, 테스트 데이터 성능 사이 차이 측정
- 케라스 지표 : `keras.metrics.Metric` 클래스 상속
- `update_state()` 메서드 : 상태 업데이트 로직

## 2. 콜백

- 케라스 콜백 : 모델 상태와 성능에 대한 모든 정보에 접근, 훈련 중지, 모델 저장, 가중치 적재, 모델 상태 변경 등 처리
    - 모델 체크포인트 저장
    - 조기 종료
    - 훈련 중 하이퍼파라미터 값 동적 조정
    - 훈련, 검증 지표 로그 기록
    - 모델 학습 표현 업데이트 시각화
- `ModelCheckpoint` 콜백 : 훈련하는 동안 모델을 계속 저장
- `EarlyStopping` 콜백 : 검증 손실이 더 이상 향상되지 않을 때 훈련을 멈춤

## 3. 사용자 정의 콜백

- `on_epoch_begin(epoch, logs)` : 각 에포크가 시작할 때 호출
- `on_epoch_end(epoch, logs)` : 각 에포크가 끝날 때 호출
- `on_batch_begin(epoch, logs)` : 각 배치 처리가 시작하기 전에 호출
- `on_batch_end(epoch, logs)` : 각 배치 처리가 끝난 후에 호출
- `on_train_begin(logs)` : 훈련이 시작될 때 호출
- `on_train_end(logs)` : 훈련이 끝날 때 호출

## 4. 텐서보드를 사용한 모니터링과 시각화

- 훈련하는 동안 측정 지표를 시각적으로 모니터링 가능
- 모델 구조 시각화 가능
- 활성화 출력과 그레이디언트 히스토그램 그리기 가능
- 임베딩 → 3D로 표현

# 4. 사용자 정의 훈련, 평가 루프 만들기

- `fit()` 워크플로 → 지도 학습에만 초점
- 그레이디언트 테이프 안에서 정방향 패스 실행
- 모델 가중치에 대한 손실의 그레이디언트 계산
- 현재 배치 데이터에 대한 손실 값을 낮추는 방향으로 모델 가중치 업데이트

## 1. 훈련 vs 추론

- 훈련 가능한 가중치 : 모델 손실을 최소화하기 위해 역전파로 업데이트
- 훈련되지 않는 가중치 : 해당 층의 정방향 패스 동안 업데이트

## 2. 측정 지표의 저수준 사용법

- 저수준 훈련 루프 → 케라스 지표

## 3. 완전한 훈련과 평가 루프

- 매 에포크 시작과 평가 전 지표 상태 재설정 필요

## 4. tf.function으로 성능 높이기

- 즉시 실행(Eager Execution) : 코드 디버깅을 쉽게 만들어줌
- 텐서플로 코드 → 계산 그래프로 컴파일

## 5. fit() 메서드를 사용자 정의 루프로 활용하기

- 사용자 정의 훈련 스템 함수 제공
- 나머지 처리 프레임워크에 위임
- `self.compiled_loss` : `compile()` 메서드에 전달한 손실 함수
- `self.compiled_metrics` : `compile()` 메서드에 전달된 지표 목록이 포함되어 있는 객체
- `self.metrics` : `compile()` 메서드에 전달한 실제 지표의 목록