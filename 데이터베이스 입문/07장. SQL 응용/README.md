# 07장. SQL 응용

# 1. 내장 함수

## 1. 내장 함수의 개요

- 내장 함수(Built-In Function) : DBMS가 제공
- 사용자 정의 함수(User-Defined Function) : 사용자가 직접 정의

### 1. MySQL 주요 내장 함수

- 숫자 함수
    - `ABS(값)` : 입력 값의 절댓값 반환
    - `CEIL(값)` : 입력 값보다 큰 정수 중에서 가장 작은 수 반환
    - `FLOOR(값)` : 입력 값보다 작은 정수 중에서 가장 큰 수 반환
    - `ROUND(값, 자리수)` : 입력 값을 소수점이하 자리수까지 반올림한 값 반환
    - `FORMAT(값, 형식)` : 입력 값을 형식에 맞게 변환하여 반환
- 문자 함수
    - `LENGTH(문자열)` : 문자열의 길이(바이트수) 반환
    - `CHAR_LENGTH(문자열)` : 문자열의 길이(문자수) 반환
    - `CONCAT(문자열_리스트)` : 콤마로 구분된 문자열, 컬럼 값들의 결합 반환
    - `LEFT/RIGHT(문자열, 길이)` : 문자열의 왼쪽/오른쪽부터 길이만큼만 반환
    - `LTRIM/RTRIM(문자열)` : 문자열의 왼쪽/오른쪽 공백을 제거하여 반환
    - `SUBSTRING(문자열, 위치, 길이)` : 문자열의 위치부터 길이 개수만큼의 부분 문자열 반환
    - `REPLACE(문자열, 검색문자열, 치환문자열)` : 문자열의 일부를 치환하여 반환
    - `REPEAT(문자열, 반복횟수)` : 문자열을 반복횟수만큼 반복하여 반환
- 날짜/시간 함수
    - `SYSDATE(), NOW()` : 현재 날짜와 시간 반환
    - `CURRENT_DATE()` : 현재 날짜 반환
    - `CURRENT_TIME()` : 현재 시간 반환
    - `YEAR(날짜), MONTH(날짜), DAY(날짜)` : 입력 날짜의 연도/월/일 부분 반환
    - `HOUR(시간), MINUTE(시간), SECOND(시간)` : 입력 시간의 시/분/초 반환
    - `LAST_DAY(날짜)` : 입력 날짜의 해당 월의 마지막 날짜 반환
    - `DATE_ADD(날짜, INTERVAL 증분값 DAY/MONTH/YEAR)` : 입력 날짜에서 증분값만큼 날/월/년을 더한 날짜 반환
    - `DATE_SUB(날짜, INTERVAL 감소값 DAY/MONTH/YEAR)` : 입력 날짜에서 감소값만큼 날/월/년을 뺀 날짜 반환
    - `DATE_FORMAT(날짜, 형식)` : 입력 날짜를 형식에 맞게 변환하여 반환
        - `%Y` : 4자리연도
        - `%y` : 2자리연도
        - `%c` : 월
        - `%m` : 월(2자리)
        - `%M` : 월(영문)
        - `%b` : 월(영문 축약)
        - `%d` : 일(2자리)
        - `%e` : 일
        - `%a` : 주(영문 축약))

## 2. 내장 함수의 적용

### 1. 숫자 함수

- 기본 사칙 연산자와 나머지 연산자 사용 가능
- 숫자 함수 제공
- 입력 : 상수 값, 열이름

### 2. 문자 함수

- 문자열을 원하는 형식으로 변환하는 유용한 함수
- 입력 : 문자열 상수 값, 열이름

### 3. 날짜/시간 함수

- 날짜형 데이터에 대한 다양한 변환과 연산 지원
- 날짜 계산 가능

# 2. 저장 프로시저(Stored Procedure)

- 미리 작성하여 데이터베이스 안에 저장한 SQL 문장들의 묶음
- 삽입/수정 저장 프로시저의 생성 및 활용

    ```sql
    CREATE PROCEDURE 프로시저_이름
    BEGIN
      ...
      SQL 명령문;
      ...
    END
    ```

- 검색 저장 프로시저의 생성 및 활용
    - 커서(Cursor) : 검색 결과 안의 행들을 한 번에 하나씩 처리하기 위해 테이블의 특정 행을 가리키는 객체
    - 실행 결과 : 여러 행이나 복수 열 포함 가능
- 저장 프로시저의 삭제

    ```sql
    DROP PROCEDURE 프로시저_이름;
    ```


# 3. 트리거(Trigger)

- 데이터 변경 등의 명세된 이벤트가 발생할 때 이를 감지하여 자동 실행되는 사용자 정의 프로시저
- 트리거의 생성 및 활용
    - 데이터 변경 시에 부수적으로 필요한 작업들을 처리하기 위해 많이 사용
    - 무결성 제약 조건 유지, 업무 규칙 적용
    - 기본 값 설정, 릴레이션 간의 데이터 제약, 뷰 수정, 참조 무결성 강화

    ```sql
    CREATE TRIGGER 트리거_이름
    [BEFORE|ALTER] [INSERT|UPDATE|DELETE] ON 테이블이름 FOR EACH ROW
    BEGIN
      ...
      SQL 명령문;
      ...
    END
    ```

    - `BEFORE` : 사전 트리거 선언
    - `ALTER` : 사후 트리거 선언
    - `OLD.열이름` : 처리 직전의 특정 열 값
    - `NEW.열이름` : 처리 직후의 특정 열 값
- 트리거의 삭제

    ```sql
    DROP TRIGGER 트리거_이름;
    ```


# 4. 사용자 정의 함수(User Defined Function)

- 사용자가 직접 정의한 함수
- DBMS 안에 독립된 데이터베이스 객체로 저장
- SELECT문이나 프로시저 안에서 호출되어 특정 기능 수행, 결과 값 반환
- 스칼라 함수 : 하나의 값 또는 NULL 반환
- 테이블 함수 : 각 행이 하나 이상의 열로 구성된 테이블 반환
- 사용자 정의 함수의 생성

    ```sql
    CREATE FUNCTION 함수명(매개변수 매개변수_자료형)
    RETURNS 반환값_자료형
    BEGIN
      ...
      SQL 명령문;
      ...
      RETURN 반환값;
    END
    ```

- 사용자 정의 함수의 삭제

    ```sql
    DROP FUNCTION 사용자정의함수_이름;
    ```


# 5. 트랜잭션(Transaction)

## 1. 트랜잭션의 개념

### 1. 트랜잭션 정의

- 한 묶음으로 처리되어야 하는 SQL 명령문들의 집합
- 트랜잭션에 속한 SQL 명령문들이 모두 정상 처리되어야 함께 완료
- 하나의 명령문이라도 오류 발생 시 전체 취소
- 커밋(Commit) : 트랜잭션의 실행 결과를 데이터베이스에 최종적으로 반영하는 것
- 롤백(Rollback) : 실행 결과를 반영하지 않고 취소하여 원래 상태로 되돌리는 것

    ```sql
    START TRANSACTION;
      ...
      SQL 명령문;
      ...
    COMMIT;
    ```


### 2. 트랜잭션의 특성 - ACID 특성

- 원자성(Atomicity) : 트랜잭션 안의 SQL 명령문을 모두 성공적으로 실행하여 완료하거나 아니면 모두 철회하여 무효화해야 함, 전부 혹은 전무
- 일관성(Consistency) : 데이터베이스가 트랜잭션 실행 전의 일관된 상태에서 트랜잭션 실행 후에도 또 다른 일관된 상태로 전환되어야 함
- 고립성(Isolation) : 커밋될 때까지 트랜잭션이 수행한 임시 실행 결과가 다른 트랜잭션에게 공개되지 않아야 함
- 지속성(Durability) : 일단 트랜잭션이 커밋되면 그 트랜잭션의 실행 결과는 장애가 발생하더라도 보존되어야 함
- 트랜잭션 지원 DBMS 모듈
    - 동시성 제어 모듈 : 동시에 실행되는 트랜잭션 간의 간섭 제어, 로킹(Locking)
    - 회복 모듈 : 완전한 트랜잭션 결과의 복구 보장, 로깅(Logging)

## 2. 트랜잭션의 종류

### 1. 명시적 트랜잭션

- 트랜잭션의 시작과 끝을 사용자가 직접 명시적으로 지정
- 사용자 트랜잭션, 수동 트랜잭션

    ```sql
    START TRANSACTION;
      ...
      SQL 명령문;
      ...
    {COMMIT|ROLLBACK};
    ```

    - `START TRANSACTION` : 직접 트랜잭션의 시작 지시
    - `COMMIT` : 트랜잭션의 처리 결과를 성공적으로 완료
    - `ROLLBACK` : 트랜잭션 처리 내용 취소, 트랜잭션 시작 이전의 원래 상태로 되돌림

### 2. 자동완료 트랜잭션

- 특별한 설정이 없을 경우 적용되는 기본 모드
- 시스템 트랜잭션

    ```sql
    SELECT @@AUTOCOMMIT;
    SET AUTOCOMMIT=1;
    ```

    - 자동커밋 옵션 설정 값 확인
    - `@@AUTOCOMMIT` : 트랜잭션 모드 설정 값을 저장하고 있는 시스템 변수
    - 자동커밋 설정 값 1 → 자동완료 트랜잭션 모드 전환

### 3. 수동완료 트랜잭션

- 트랜잭션의 끝만 사용자가 직접 명시적으로 지정
- 암시적 트랜잭션
- `CREATE, ALTER, INSERT, UPDATE, DELETE, SELECT, DROP, FETCH, GRANT, OPEN, REVOKE, TRUNCATE TABLE` → 트랜잭션 자동 시작

    ```sql
    SELECT @@AUTOCOMMIT; # 자동커밋 현재 설정 상태 확인
    SET AUTOCOMMIT=0; # 수동완료 모드 설정(자동완료 모드 해제)
    ```


## 3. 트랜잭션과 로그

### 1. 트랜잭션 처리 과정

- 데이터 변경 요청 → DBMS의 쿼리 처리기를 통해 SQL 명령문 접수/해석
- 데이터 페이지 블록 → 주기억장치의 데이터베이스 버퍼 캐시 영역 로드
- 데이터베이스 버퍼 캐시 안 해당 페이지를 대상으로 검색/데이터 페이지 내용 변경
- 로그 먼저 쓰기 규약(Write-Ahead Log Protocol) : 매번 트랜잭션 처리 직전에 먼저 디스크 안의 로그 데이터베이스 파일에 안전하게 기록
- 로그 데이터베이스 : 트랜잭션의 모든 데이터 변경 사항을 저장 데이터베이스 파일에 반영하기 전에 미리 기록하는 특별한 데이터베이스
- 백업 데이터베이스 : 데이터베이스 파일의 물리적 손상에 대비하여 별도로 저장한 복제 데이터베이스
    - 전체 백업(Full Backup) : 매번 전체 데이터베이스의 복사본 저장
    - 차등 백업(Deferential Backup) : 이전 전체 데이터베이스의 복사본과 차이가 있는 변경 데이터 부분만 추가로 백업
    - 증분 백업(Incremental Backup) : 전체 데이터베이스 복사본과 이후의 로그 데이터베이스 복사본 저장
    - 복원(Restore) : 백업 데이터베이스를 사용하여 원래 상태로 되돌리는 작업

### 2. 트랜잭션 로그

- 로그를 통한 회복 → 트랜잭션 단위

    ```sql
    [트랜잭션_식별자, 로그_유형, 데이터_항목, 변경전_값, 변경후_값]
    ```

- 체크 포인트(Check Point) : 특정 시점까지의 데이터 버퍼 안의 모든 변경 내용을 데이터베이스 파일에 물리적으로 저장하는 시점, 검사점

### 3. 로그를 이용한 회복 기법

- 장애 발생 시점에 이미 커밋된 트랜잭션의 변경 내용은 로그를 이용하여 반드시 데이터베이스에 반영
- 회복 → 롤백시키기 위해 최소 작업 진행
- 마지막 체크 포인트 이후 커밋되지 않은 트랜잭션의 로그 내용 → 모두 롤백
- 장애 발생 시점까지 정상적으로 종료된 트랜잭션의 실행 결과 보장 → 재실행 작업 진행
- 마지막 체크 포인트 이후의 커밋된 트랜잭션의 로그 내용 → 롤포워드(Rollforward)

## 4. 트랜잭션과 로크

- 로크 잠금 : 다중 사용자 환경에서 동시 접근을 올바르게 제어하기 위한 대표적 기법

### 1. 로크의 개념

- 바람직한 동시성(Concurrency) : 비직렬 스케쥴의 결과가 트랜잭션을 뒤섞지 않고 순차적으로 실행하는 직렬 스케쥴의 결과와 같도록보장하는 것
- 직렬 가능(Serializable)
- 로크의 종류 - 공유 로크(Shared Lock)
    - 잠금 목적 : 읽기 목적
    - 잠금 시작 : SELECT문 실행 시
    - 잠금 해제 : SELECT문 실행 직후 또는 트랜잭션 종료 후
    - 특성 : 다른 공유 로크와는 양립하지만 독립 로크와는 양립하지 않음
- 로크의 종류 - 독점 로크(Exclusive Lock)
    - 잠금 목적 : 쓰기 목적
    - 잠금 시작 : INSERT, UPDATE, DELETE문 실행 직전
    - 잠금 해제 : 트랜잭션 종료 후
    - 특성 : 어떤 다른 로크와도 양립하지 않음

### 2. 로크 설정과 해제

- 로크 단위(Lock Granularity) : 로크 잠금 대상의 크기
- 로크 양립성(Lock Compatability) : 2가지 유형의 로크 사이에 서로 추가 잠금 허용 여부 결정
- 2단계 로킹 규약과 로크 해제
    - 1단계 - 로크 확장 단계(Growing Phase) : 접근하고자 하는 데이터에 대한 모든 로크를 획득할 때까지 새로운 로크를 지속적으로 요청하여 잠금 설정
    - 2단계 - 로크 축소 단계(Shrinking Phase) : 필요로 하는 모든 로크를 획득하는 시점인 로크 포인트가 되면 보유하고 있던 로크를 점차적으로 해제
- 교착 상태(Dead Lock) : 둘 이상의 트랜잭션의 로크가 서로 얽혀서 영원히 풀리지 않는 상태

### 3. 트랜잭션의 고립 수준

- 고립 수준(Isolation Level) : 트랜잭션이 다른 트랜잭션과 고립되는 정도
- 수준 0
    - 고립 수준 키워드 : READ UNCOMMITTED
    - 발생 문제 유형 : 오손 데이터 읽기, 반복 불가능 읽기, 유령 데이터 읽기
    - 로크 설정 : SELECT문(로크 관계없이 자유롭게 읽음), UPDATE/DELETE문(독점 로크 설정 및 유지)
- 수준 1
    - 고립 수준 키워드 : READ COMMITTED
    - 발생 문제 유형 : 반복 불가능 읽기, 유령 데이터 읽기
    - 로크 설정 : SELECT문(공유 로크 설정, 실행 후 즉시 해제), UPDATE/DELETE문(독점 로크 설정 및 유지)
- 수준 2
    - 고립 수준 키워드 : REPEATABLE READ
    - 발생 문제 유형 : 유령 데이터 읽기
    - 로크 설정 : SELECT문(공유 로크 설정 및 유지), UPDATE/DELETE문(독점 로크 설정 및 유지)
- 수준 3
    - 고립 수준 키워드 : SERIALIZABLE
    - 발생 문제 유형 : 없음
    - 로크 설정 : SELECT문(공유 로크 설정 및 유지), UPDATE/DELETE문(독점 로크 설정 및 유지), 인덱스 공유 로크 설정 및 유지(다른 트랜잭션의 INSERT문 수행 방지)
- 오손 데이터 읽기(Dirty Data Read) 문제 : 커밋되지 않은 트랜잭션의 수정된 중간 결과를 읽어오는 것이 허용된다면 발생할 수 있는 문제
- 반복 불가능 읽기(Non-Repeatable Read) 문제 : 트랜잭션이 읽어서 처리중인 데이터를 다른 트랜잭션이 자유롭게 변경하는 것이 허용된다면 발생할 수 있는 문제
- 유령 데이터 읽기(Phantom Data Read) 문제 : 트랜잭션이 읽어서 처리중인 데이터를 다른 트랜잭션이 변경하는 것을 방지하더라도 다른 트랜잭션의 데이터 추가가 허용된다면 발생할 수 있는 문제
- 고립 수준 정의

    ```sql
    SET TRANSACTION ISOLATION LEVEL 고립_수준_키워드;
    
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; # 고립수준 0
    SET TRANSACTION ISOLATION LEVEL READ COMMITTED; # 고립수준 1
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; # 고립수준 2
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; # 고립수준 3
    ```